<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Quantum Rat v3.5: Tabbed UI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
      }
    </script>
    <style>
        body { background-color: #050505; color: #eee; font-family: monospace; }
        #three-container { width: 100%; height: 100%; overflow: hidden; position: relative; }
        canvas { outline: none; }
        .btn { padding: 0.5rem 1rem; background-color: #1f2937; border: 1px solid #4b5563; border-radius: 0.375rem; color: inherit; cursor: pointer; transition: all 0.2s; }
        .btn:hover { background-color: #374151; border-color: #6b7280; }
        .tab-btn { padding-bottom: 0.5rem; text-transform: uppercase; font-size: 0.75rem; font-weight: bold; color: #71717a; border-bottom: 2px solid transparent; transition: all 0.2s; }
        .tab-btn.active { color: #22d3ee; border-bottom-color: #22d3ee; }
        .tab-btn:hover:not(.active) { color: #a1a1aa; }
        
        #pip-label { position: absolute; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 2px 5px; font-size: 10px; color: cyan; border: 1px solid #004444; pointer-events: none; z-index: 10; }
        .scanlines { background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2)); background-size: 100% 4px; pointer-events: none; }
        /* Scrollbar hiding for cleaner look */
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #18181b; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #3f3f46; border-radius: 3px; }

        /* Global tooltip */
        #global-tooltip {
            position: fixed;
            background: rgba(10, 10, 15, 0.95);
            border: 1px solid #06b6d4;
            color: #ecfeff;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.75rem;
            pointer-events: none;
            z-index: 9999;
            max-width: 250px;
            box-shadow: 0 0 10px rgba(6, 182, 212, 0.2);
            display: none;
            backdrop-filter: blur(4px);
            line-height: 1.4;
        }

        #global-tooltip strong {
            display: block;
            color: #22d3ee;
            margin-bottom: 4px;
            border-bottom: 1px solid #164e63;
            padding-bottom: 2px;
        }
        /* CRT Scanline Effect */
        .image-pixelated {
            image-rendering: pixelated;
        }
        .active-tab-class {
            color: #22d3ee;
            border-bottom: 2px solid #22d3ee;
            background: rgba(34, 211, 238, 0.1);
        }
        /* Glassmorphism scrollbar */
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #334155; border-radius: 2px; }
    </style>
</head>
<body class="h-screen flex flex-col p-4 overflow-hidden bg-zinc-950">
    <div id="global-tooltip"></div>

    <div class="flex justify-between items-center mb-4 border-b border-zinc-800 pb-2">
        <div>
            <h1 class="text-cyan-400 font-bold text-xl tracking-wider">QUANTUM RAT v3.5</h1>
            <span class="text-xs text-cyan-700">Orch-OR Biomimetic Agent // Hebbian Plasticity</span>
        </div>
        <div class="flex gap-2 items-center">
            <button id="btn-turbo" class="btn text-yellow-400 border-yellow-900/50 hover:border-yellow-500">⚡ Hyper-Train</button>
            <div class="w-4 border-r border-zinc-800 h-6 mx-2"></div>
            <input type="number" id="load-gen-input" placeholder="Gen ID" class="bg-zinc-900 border border-zinc-700 rounded px-2 py-1 w-20 text-white focus:outline-none focus:border-cyan-500">
            <button onclick="loadGen()" class="btn text-purple-300 border-purple-900/50 hover:border-purple-500">Time Travel</button>
            <button id="btn-play" class="btn border-zinc-700">Pause</button>
            <button onclick="resetRat()" class="btn text-red-400 border-red-900/50 hover:border-red-500">Wipe</button>
        </div>
    </div>

    <div class="flex flex-1 gap-4 min-h-0">
        <div class="flex-1 bg-black border border-cyan-900/30 rounded relative overflow-hidden shadow-[0_0_15px_rgba(0,255,255,0.1)]">
            <div id="three-container" class="transition-all duration-500"></div>
            
            <div id="energy-vignette" class="absolute inset-0 pointer-events-none opacity-0 transition-opacity duration-1000"
                 style="background: radial-gradient(circle, transparent 30%, rgba(10,10,10,0.9) 90%); z-index: 20;">
            </div>

            <div id="status-overlay" class="absolute top-4 left-4 text-cyan-500 text-sm font-bold pointer-events-none" style="text-shadow: 0 0 5px cyan; z-index: 30;">AWAKE</div>
            <div id="pip-label">SENSORY: VIBRISSAL (8Hz)</div>
        </div>

        <div class="w-96 flex flex-col bg-zinc-950 border-l border-zinc-900 pl-4">
            
            <div class="flex gap-4 mb-4 border-b border-zinc-800">
                <button class="tab-btn active" onclick="setTab('monitor')" id="tab-btn-monitor">Monitor</button>
                <button class="tab-btn" onclick="setTab('controls')" id="tab-btn-controls">Controls</button>
                <button class="tab-btn" onclick="setTab('research')" id="tab-btn-research">Research</button>
            </div>

            <div class="flex-1 overflow-y-auto custom-scrollbar pr-2 relative">
                
                <div id="view-monitor" class="flex flex-col gap-4">
                    <div class="flex flex-col gap-2">
                        <div class="flex gap-2">
                            <div class="bg-zinc-900 p-2 rounded border border-zinc-800 flex-1 group relative" data-tip="soma">
                                <h3 class="text-[10px] text-zinc-500 mb-1 uppercase tracking-widest">Soma (Decision)</h3>
                                <canvas id="cvs-brain" width="64" height="13" class="w-full h-12 bg-black border border-zinc-800"></canvas>
                            </div>
                            <div class="bg-zinc-900 p-2 rounded border border-zinc-800 flex-1 group relative" data-tip="theta">
                                <h3 class="text-[10px] text-zinc-500 mb-1 uppercase tracking-widest">Theta (Memory)</h3>
                                <canvas id="cvs-mem" width="64" height="13" class="w-full h-12 bg-black border border-zinc-800"></canvas>
                            </div>
                        </div>
                        <div class="flex gap-2">
                            <div class="bg-zinc-900 p-2 rounded border border-zinc-800 relative flex-1" data-tip="grid">
                                <h3 class="text-[10px] text-zinc-500 mb-1 uppercase tracking-widest">Entorhinal Grid</h3>
                                <canvas id="cvs-grid" width="32" height="32" class="w-full h-24 bg-black border border-zinc-800 image-pixelated"></canvas>
                                <div class="absolute inset-0 scanlines opacity-50"></div>
                            </div>
                            <div class="bg-zinc-900 p-2 rounded border border-zinc-800 relative w-24 flex flex-col items-center" data-tip="hd">
                                <h3 class="text-[10px] text-zinc-500 mb-1 uppercase tracking-widest text-center">HD Compass</h3>
                                <canvas id="cvs-hd" width="64" height="64" class="w-20 h-20 bg-black border border-zinc-800 rounded-full"></canvas>
                            </div>
                        </div>
                    </div>

                    <div class="bg-zinc-900 p-4 rounded border border-zinc-800 space-y-3" data-tip="physio">
                         <div>
                             <div class="flex justify-between text-xs mb-1"><span class="text-orange-500 font-semibold">FRUSTRATION</span><span id="val-frust" class="text-orange-300">0.00</span></div>
                            <div class="h-2 bg-zinc-800 rounded overflow-hidden relative"><div id="bar-frust" class="h-full bg-gradient-to-r from-orange-600 to-orange-400 w-0 transition-all duration-200"></div></div>
                        </div>
                         <div>
                            <div class="flex justify-between text-xs mb-1 pt-1"><span class="text-blue-500 font-semibold">DOPAMINE</span><span id="val-dopa" class="text-blue-300">0.20</span></div>
                           <div class="h-2 bg-zinc-800 rounded overflow-hidden relative"><div id="bar-dopa" class="h-full bg-gradient-to-r from-blue-600 to-blue-400 w-0 transition-all duration-200"></div></div>
                       </div>
                        <div class="pt-2 border-t border-zinc-800/50">
                            <div class="flex justify-between text-xs mb-1">
                                <span class="text-purple-400 font-semibold">GLYCOGEN</span><span id="val-energy" class="text-purple-300">100%</span>
                            </div>
                            <div class="h-2 bg-zinc-800 rounded overflow-hidden relative mb-2">
                                <div id="bar-energy" class="h-full bg-purple-600 w-full transition-all duration-200"></div>
                            </div>
                            <div class="flex justify-between text-xs mb-1">
                                <span class="text-yellow-400 font-semibold">NEURONAL ATP</span><span id="val-atp" class="text-yellow-300">100%</span>
                            </div>
                            <div class="h-2 bg-zinc-800 rounded overflow-hidden relative">
                                <div id="bar-atp" class="h-full bg-yellow-400 w-full transition-all duration-200 shadow-[0_0_10px_yellow]"></div>
                            </div>
                        </div>
                    </div>

                    <div class="grid grid-cols-4 gap-2 text-center">
                        <div class="bg-zinc-950 p-2 rounded border border-zinc-800"><div class="text-[10px] text-zinc-500 uppercase">Score</div><div id="val-score" class="text-xl font-bold text-green-400">0</div></div>
                        <div class="bg-zinc-950 p-2 rounded border border-zinc-800"><div class="text-[10px] text-zinc-500 uppercase">Gen</div><div id="val-gen" class="text-xl font-bold text-purple-400">1</div></div>
                        <div class="bg-zinc-950 p-2 rounded border border-zinc-800"><div class="text-[10px] text-zinc-500 uppercase">Deaths</div><div id="val-deaths" class="text-xl font-bold text-red-400">0</div></div>
                        <div class="bg-zinc-950 p-2 rounded border border-cyan-900/50"><div class="text-[10px] text-zinc-500 uppercase">Mems</div><div id="val-mems" class="text-xl font-bold text-blue-400">0</div></div>
                   </div>
                </div>

                <div id="view-controls" class="hidden flex-col gap-4">
                     <div class="bg-zinc-900 p-3 rounded border border-zinc-800">
                         <h3 class="text-[10px] text-zinc-500 mb-3 uppercase tracking-widest border-b border-zinc-800 pb-1">Simulation Config</h3>
                         
                         <label class="text-xs text-zinc-400 flex justify-between" data-tip="speed"><span>Speed</span> <span id="speed-val">1x</span></label>
                        <input type="range" class="w-full h-1 bg-zinc-700 rounded appearance-none outline-none mt-2" min="1" max="10" value="1" oninput="updateConfig('speed', this.value); document.getElementById('speed-val').innerText = this.value + 'x'">
                        
                        <label class="text-xs text-zinc-400 flex justify-between mt-4" data-tip="anesthesia"><span>Anesthesia</span> <span id="anes-val">0.0</span></label>
                        <input type="range" class="w-full h-1 bg-zinc-700 rounded appearance-none outline-none mt-2" min="0" max="1" step="0.1" value="0" oninput="updateConfig('anesthetic', this.value); document.getElementById('anes-val').innerText = this.value">

                        <label class="text-xs text-zinc-400 flex justify-between mt-4" data-tip="downsample"><span>Downsample</span> <span id="ds-val">1x</span></label>
                        <input type="range" class="w-full h-1 bg-zinc-700 rounded appearance-none outline-none mt-2" min="1" max="4" step="1" value="1" oninput="updateConfig('downsample', this.value); document.getElementById('ds-val').innerText = this.value + 'x'">
                        
                        <div class="flex items-center gap-2 mt-4 pt-2 border-t border-zinc-800">
                            <input type="checkbox" id="chk-pip" checked class="accent-cyan-500">
                            <label for="chk-pip" class="text-xs text-zinc-400">Show Rat Vision (PiP)</label>
                        </div>
                    </div>

                     <div class="bg-zinc-900 p-3 rounded border border-zinc-800">
                        <h3 class="text-[10px] text-zinc-500 mb-3 uppercase tracking-widest border-b border-zinc-800 pb-1">Component Ablation</h3>
                        
                        <label class="text-xs text-zinc-400 flex justify-between" data-tip="cerebellum"><span class="text-cyan-400">Cerebellum</span> <span id="cer-val">1.0</span></label>
                        <input type="range" class="w-full h-1 bg-zinc-700 rounded appearance-none outline-none mt-1 mb-3" min="0" max="2" step="0.1" value="1" oninput="updateConfig('cerebellum_gain', this.value); document.getElementById('cer-val').innerText = this.value">

                        <label class="text-xs text-zinc-400 flex justify-between" data-tip="hippocampus"><span class="text-purple-400">Hippocampus</span> <span id="mem-val">1.0</span></label>
                        <input type="range" class="w-full h-1 bg-zinc-700 rounded appearance-none outline-none mt-1 mb-3" min="0" max="3" step="0.1" value="1" oninput="updateConfig('memory_gain', this.value); document.getElementById('mem-val').innerText = this.value">

                        <label class="text-xs text-zinc-400 flex justify-between" data-tip="amygdala"><span class="text-red-400">Amygdala</span> <span id="fear-val">1.0</span></label>
                        <input type="range" class="w-full h-1 bg-zinc-700 rounded appearance-none outline-none mt-1 mb-3" min="0" max="5" step="0.1" value="1" oninput="updateConfig('fear_gain', this.value); document.getElementById('fear-val').innerText = this.value">
                        
                        <div class="flex items-center justify-between mt-1" data-tip="energy_chk">
                            <label class="text-xs text-yellow-400">Metabolic Limits</label>
                            <input type="checkbox" id="chk-energy" checked class="accent-yellow-500" onchange="updateConfig('energy_constraint', this.checked ? 1.0 : 0.0)">
                        </div>

                        <div class="mt-4 border-t border-zinc-800/50 pt-3 space-y-3">
                          <h4 class="text-[10px] text-zinc-500 uppercase tracking-widest">Sensory Pathway</h4>
                          <div class="flex items-center justify-between"><label class="text-xs text-cyan-300">Sensory Cortex</label><input type="checkbox" id="chk-sensory" class="accent-cyan-500" onchange="updateConfig('enable_sensory_cortex', this.checked ? 1.0 : 0.0)"></div>
                          <div class="flex items-center justify-between"><label class="text-xs text-green-300">Thalamus Relay</label><input type="checkbox" id="chk-thalamus" class="accent-green-500" onchange="updateConfig('enable_thalamus', this.checked ? 1.0 : 0.0)"></div>
                          <label class="text-xs text-zinc-400 flex justify-between"><span class="text-yellow-300">Blend (Old ↔ New)</span><span id="blend-val">0.0</span></label>
                          <input type="range" class="w-full h-1 bg-zinc-700 rounded appearance-none outline-none mt-1" min="0" max="1" step="0.05" value="0" oninput="updateConfig('sensory_blend', this.value); document.getElementById('blend-val').innerText = this.value">
                        </div>

                        <div class="mt-4 border-t border-zinc-800/50 pt-3 space-y-3">
                          <h4 class="text-[10px] text-zinc-500 uppercase tracking-widest">Hippocampal Replay</h4>

                          <div class="flex items-center justify-between" data-tip="replay_enable">
                            <label class="text-xs text-emerald-300">Enable Replay</label>
                            <input type="checkbox" id="chk-replay" class="accent-emerald-500"
                                   onchange="updateConfig('enable_replay', this.checked ? 1.0 : 0.0)">
                          </div>

                          <label class="text-xs text-zinc-400 flex justify-between" data-tip="replay_strength">
                            <span class="text-emerald-300">Replay Strength</span><span id="replay-strength-val">0.15</span>
                          </label>
                          <input type="range" class="w-full h-1 bg-zinc-700 rounded appearance-none outline-none mt-1"
                                 min="0" max="1" step="0.05" value="0.15"
                                 oninput="updateConfig('replay_strength', this.value); document.getElementById('replay-strength-val').innerText = this.value">

                          <label class="text-xs text-zinc-400 flex justify-between" data-tip="replay_steps">
                            <span class="text-emerald-300">Replay Steps</span><span id="replay-steps-val">6</span>
                          </label>
                          <input type="range" class="w-full h-1 bg-zinc-700 rounded appearance-none outline-none mt-1"
                                 min="0" max="20" step="1" value="6"
                                 oninput="updateConfig('replay_steps', this.value); document.getElementById('replay-steps-val').innerText = this.value">
                        </div>
                    </div>
                </div>

                <div id="view-research" class="hidden flex-col gap-4">
                     <div class="bg-zinc-900 p-4 rounded border border-blue-900/50 relative overflow-hidden" data-tip="learning_curve">
                        <div class="absolute top-0 right-0 p-1"><span class="text-[10px] bg-blue-900 text-blue-200 px-1 rounded">RESEARCH MODE</span></div>
                        <h3 class="text-[10px] text-zinc-500 mb-2 uppercase tracking-widest font-bold">Laboratory Protocols</h3>
                        
        <select id="lab-protocol-select" class="w-full bg-zinc-800 text-xs text-zinc-300 border border-zinc-700 rounded p-1 mb-2 outline-none">
            <option value="open_field">1. Open Field Test (Anxiety/Entropy)</option>
            <option value="t_maze">2. T-Maze Alternation (Working Memory)</option>
            <option value="spatial_learning" disabled>3. Morris Water Maze (Coming Soon)</option>
        </select>

                        <div class="flex gap-2 mb-3">
                            <button onclick="toggleLab(true)" id="btn-start-lab" class="flex-1 btn bg-blue-900/20 text-blue-400 border-blue-800 hover:bg-blue-800/30 text-xs">Run Protocol</button>
                            <button onclick="toggleLab(false)" id="btn-stop-lab" class="flex-1 btn bg-red-900/20 text-red-400 border-red-800 hover:bg-red-800/30 text-xs hidden">Abort</button>
                        </div>

                        <div class="relative bg-black border border-zinc-800 rounded w-full">
                            <canvas id="cvs-learning-curve" width="350" height="200" class="w-full"></canvas>
                            <div id="lab-overlay" class="absolute inset-0 flex items-center justify-center text-zinc-600 text-xs pointer-events-none">NO DATA</div>
                        </div>
                        <p id="lab-status-text" class="text-[10px] text-zinc-500 mt-2">Select a protocol to begin analysis.</p>
                    </div>

                    <div class="bg-zinc-900 p-3 rounded border border-zinc-800 group relative" data-tip="genetic_graph">
                        <h3 class="text-[10px] text-zinc-500 mb-2 uppercase tracking-widest">Genetic Drifts</h3>
                        <canvas id="cvs-graph" width="350" height="150" class="w-full bg-zinc-950 border border-zinc-800/50 rounded"></canvas>
                        <div class="mt-2 text-[10px] text-zinc-500 flex gap-4 justify-center">
                            <span class="text-red-400">● Amygdala</span>
                            <span class="text-blue-400">● Striatum</span>
                            <span class="text-green-400">● Hippocampus</span>
                        </div>
                    </div>
                </div>

            </div>
        </div>
    </div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- TOOLTIP TEXT DICTIONARY ---
    const TOOLTIP_TEXT = {
        "soma": {
            title: "Executive Soma",
            text: "Visualizes quantum dipole coherence in microtubules. Bright spots indicate 'Orch OR' collapse events that drive motor decisions."
        },
        "theta": {
            title: "Theta Memory (Hippocampus)",
            text: "Time-encoded lattice representing Short-Term Memory. Activity here tracks synaptic tagging and sequential event capture."
        },
        "grid": {
            title: "Entorhinal Grid Cells",
            text: "Hexagonal firing fields providing a metric coordinate system for path integration and spatial mapping."
        },
        "hd": {
            title: "Head Direction (Postsubiculum)",
            text: "A ring-attractor network acting as a neural compass. The green line indicates the rat's belief of 'North'."
        },
        "physio": {
            title: "Physiological State",
            text: "Real-time tracking. High frustration drives exploration. Low ATP triggers 'Brain Fog'—shutting down cortical planning to conserve energy."
        },
        "speed": {
            title: "Simulation Speed",
            text: "Controls the number of physics steps calculated per frame. Higher values train faster but may lower frame rate."
        },
        "anesthesia": {
            title: "Anesthetic (Isoflurane)",
            text: "Dampens quantum coherence in microtubules. At high levels, consciousness ceases, and the rat will stop moving."
        },
        "downsample": {
            title: "Data Downsampling",
            text: "Reduces the resolution of brain data sent from Python to JS. Increase this if the simulation is lagging."
        },
        "cerebellum": {
            title: "Cerebellum Gain",
            text: "Modulates fine motor control. 0.0 results in clumsy/jittery movement; 1.0 results in smooth, predicted trajectories."
        },
        "hippocampus": {
            title: "Hippocampus Weight",
            text: "Controls how much the rat relies on memory vs. immediate sensory input. High values favor learned paths."
        },
        "amygdala": {
            title: "Amygdala Weight",
            text: "Controls the fear response to predators. High values cause the rat to prioritize safety over food."
        },
        "energy_chk": {
            title: "Metabolic Constraints",
            text: "If enabled, the rat can die of starvation (0% ATP). If disabled, the rat has infinite energy."
        },
        "learning_curve": {
            title: "Latency Analysis",
            text: "Plots the time (in frames) taken to find the target across repeated trials. A downward slope indicates successful spatial learning."
        },
        "genetic_graph": {
            title: "Evolutionary History",
            text: "Tracks the genetic weights of the brain over generations. Use this to see if the population is becoming more fearful or more greedy."
        },
        "replay_enable": {
            title: "Hippocampal Replay",
            text: "During microsleep, replays recent hippocampal state snapshots to consolidate learning (offline)."
        },
        "replay_strength": {
            title: "Replay Strength",
            text: "How strongly replay nudges consolidation. Keep small to avoid destabilising online behaviour."
        },
        "replay_steps": {
            title: "Replay Steps",
            text: "How many snapshots replayed per microsleep. More = stronger offline learning, but heavier compute."
        }
    };

    let running = true;
    let turboMode = false;
    let lastScore = 0;
    let lastGen = 1;

    let turboBatch = 200;   // practical ceiling
    let normalMaxSpeed = 10;

    // --- TAB SYSTEM ---
    window.setTab = function(tabName) {
        // Toggle Buttons
        ['monitor', 'controls', 'research'].forEach(t => {
            const btn = document.getElementById(`tab-btn-${t}`);
            const view = document.getElementById(`view-${t}`);
            
            if(t === tabName) {
                btn.classList.add('active');
                view.classList.remove('hidden');
                view.classList.add('flex');
            } else {
                btn.classList.remove('active');
                view.classList.add('hidden');
                view.classList.remove('flex');
            }
        });
    };

    async function setTurboMode(on) {
      turboMode = on;
      const btn = document.getElementById('btn-turbo');
      btn.innerText = turboMode ? "⚡ TRAINING..." : "⚡ Hyper-Train";
      await fetch('/config', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ max_speed: turboMode ? turboBatch : normalMaxSpeed })
      });
    }
    
    // --- THREE.JS SETUP ---
    const container = document.getElementById('three-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.02); 

    const mainCamera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
    mainCamera.position.set(20, 35, 55); 
    
    const ratCamera = new THREE.PerspectiveCamera(110, 4/3, 0.05, 50); 
    
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setClearColor(0x050505);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(mainCamera, renderer.domElement);
    controls.target.set(20, 0, 20);
    controls.update();

    const ambientLight = new THREE.AmbientLight(0x222222);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xffffff, 0.5);
    sunLight.position.set(50, 50, -20);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048; sunLight.shadow.mapSize.height = 2048;
    scene.add(sunLight);

    // --- MATERIALS ---
    const matWall = new THREE.MeshLambertMaterial({ color: 0x111111, emissive: 0x004444, emissiveIntensity: 0.8 });
    const matWallWire = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.1 }); 
    const matGround = new THREE.MeshPhongMaterial({ color: 0x080808, shininess: 80 });
    const matRat = new THREE.MeshPhongMaterial({ color: 0x00ffff, emissive: 0x0088ff, emissiveIntensity: 0.5 });
    const matPredator = new THREE.MeshPhongMaterial({ color: 0xff00ff, emissive: 0x550055, emissiveIntensity: 0.8 });
    const matTarget = new THREE.MeshPhongMaterial({ color: 0xffd700, emissive: 0xffaa00, emissiveIntensity: 0.8 });
    const matPheromone = new THREE.MeshBasicMaterial({ color: 0x00ff66 });
    const matPhantom = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.2, wireframe: true });
    const matMemory = new THREE.MeshBasicMaterial({ color: 0x0088ff, wireframe: true, transparent: true, opacity: 0.6 });
    const matVisionCone = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.05, side: THREE.DoubleSide });

    let wallsInstancedMesh, wireframeBox;
    let ratMesh, predatorMesh, targetMeshes, targetLights;
    let pheromoneMeshes = [], phantomMeshes = [];
    let memoryObjects = [];
    let leftWhisker, rightWhisker;
    let visionGroup;
    const visionLines = [];
    const MAP_SIZE = 40;

    function initSceneObjects() {
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE), matGround);
        ground.rotation.x = -Math.PI / 2;
        ground.position.set(MAP_SIZE / 2 - 0.5, 0, MAP_SIZE / 2 - 0.5);
        ground.receiveShadow = true;
        scene.add(ground);
        
        const gridHelper = new THREE.GridHelper(MAP_SIZE, MAP_SIZE, 0x003333, 0x001111);
        gridHelper.position.set(MAP_SIZE / 2 - 0.5, 0.01, MAP_SIZE / 2 - 0.5);
        scene.add(gridHelper);

        ratMesh = new THREE.Mesh(new THREE.ConeGeometry(0.4, 1, 8), matRat);
        ratMesh.castShadow = true; 
        
        ratMesh.add(ratCamera);
        ratCamera.position.set(0, 0.2, 0.2); 
        ratCamera.rotation.x = -Math.PI / 2; 
        
        const visionGeo = new THREE.ConeGeometry(4, 8, 32, 1, true, 0, 1.9); 
        const visionCone = new THREE.Mesh(visionGeo, matVisionCone);
        visionCone.position.y = 4; visionCone.rotation.x = Math.PI; 
        ratMesh.add(visionCone);
        
        scene.add(ratMesh);

        predatorMesh = new THREE.Mesh(new THREE.IcosahedronGeometry(0.5, 0), matPredator);
        predatorMesh.castShadow = true; scene.add(predatorMesh);

        targetMeshes = [];
        targetLights = [];
        for(let i = 0; i < 3; i++) { 
            const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), matTarget);
            const light = new THREE.PointLight(0xffaa00, 1, 10);
            mesh.add(light);
            scene.add(mesh);
            targetMeshes.push(mesh);
            targetLights.push(light);
        }

        for(let i=0; i<500; i++) {
            const pMesh = new THREE.Mesh(new THREE.SphereGeometry(0.1, 4, 4), matPheromone);
            pMesh.visible = false; scene.add(pMesh); pheromoneMeshes.push(pMesh);
        }
        for(let i=0; i<15; i++) {
            const phMesh = new THREE.Mesh(new THREE.ConeGeometry(0.4, 1, 4), matPhantom);
            phMesh.visible = false; scene.add(phMesh); phantomMeshes.push(phMesh);
        }

        const whiskerMat = new THREE.LineBasicMaterial({ color: 0xaaaaaa });
        const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 4)]);
        leftWhisker = new THREE.Line(geometry, whiskerMat.clone());
        leftWhisker.position.set(-0.2, 0, 0.5); 
        ratMesh.add(leftWhisker);
        rightWhisker = new THREE.Line(geometry, whiskerMat.clone());
        rightWhisker.position.set(0.2, 0, 0.5);
        ratMesh.add(rightWhisker);

        visionGroup = new THREE.Group();
        ratMesh.add(visionGroup);
        const lineMat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5 });
        for(let i=0; i<12; i++) {
            const geo = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,1) ]);
            const line = new THREE.Line(geo, lineMat.clone());
            visionLines.push(line);
            visionGroup.add(line);
        }
    }

    function buildWalls(walls) {
        if(wallsInstancedMesh) { scene.remove(wallsInstancedMesh); scene.remove(wireframeBox); }
        const boxGeo = new THREE.BoxGeometry(1, 1, 1);
        const edges = new THREE.EdgesGeometry(boxGeo);
        wallsInstancedMesh = new THREE.InstancedMesh(boxGeo, matWall, walls.length);
        wallsInstancedMesh.castShadow = true; wallsInstancedMesh.receiveShadow = true;
        const dummy = new THREE.Object3D();
        walls.forEach((w, i) => {
            dummy.position.set(w[0], 0.5, w[1]); dummy.updateMatrix();
            wallsInstancedMesh.setMatrixAt(i, dummy.matrix);
        });
        wallsInstancedMesh.instanceMatrix.needsUpdate = true;
        scene.add(wallsInstancedMesh);
        wireframeBox = new THREE.InstancedMesh(edges, matWallWire, walls.length);
        walls.forEach((w, i) => {
             dummy.position.set(w[0], 0.5, w[1]); dummy.updateMatrix();
             wireframeBox.setMatrixAt(i, dummy.matrix);
        });
        wireframeBox.instanceMatrix.needsUpdate = true;
        scene.add(wireframeBox);
    }
    
    function spawnMemoryMarker(pos) {
        const geo = new THREE.OctahedronGeometry(0.4, 0);
        const mesh = new THREE.Mesh(geo, matMemory);
        mesh.position.set(pos.x, 1.0, pos.z); 
        scene.add(mesh);
        memoryObjects.push(mesh);
    }
    function clearMemories() {
        memoryObjects.forEach(m => scene.remove(m));
        memoryObjects = [];
    }

    initSceneObjects();

    // --- CANVAS DIAGNOSTICS ---
    const ctxBrain = document.getElementById('cvs-brain').getContext('2d');
    const ctxMem = document.getElementById('cvs-mem').getContext('2d');
    const ctxGrid = document.getElementById('cvs-grid').getContext('2d');
    const ctxHD = document.getElementById('cvs-hd').getContext('2d');
    
    const cvsGraph = document.getElementById('cvs-graph');
    const ctxGraph = cvsGraph.getContext('2d');
    
    const cvsLearning = document.getElementById('cvs-learning-curve');
    const ctxLearning = cvsLearning.getContext('2d');
    let isLabActive = false;

    function resizeThree() {
        const w = container.clientWidth, h = container.clientHeight;
        mainCamera.aspect = w / h; mainCamera.updateProjectionMatrix();
        renderer.setSize(w, h);
    }
    window.onresize = resizeThree;

    function drawHeatmap(ctx, data, colorFn) {
        if(!data || !data.length) return;
        const w = data[0].length, h = data.length;
        if(ctx.canvas.width !== w) { ctx.canvas.width = w; ctx.canvas.height = h; }
        const img = ctx.createImageData(w, h);
        for(let i=0; i<h; i++) {
            for(let j=0; j<w; j++) {
                const val = data[i][j]; const idx = (i*w + j) * 4; const rgb = colorFn(val);
                img.data[idx] = rgb[0]; img.data[idx+1] = rgb[1]; img.data[idx+2] = rgb[2]; img.data[idx+3] = 255;
            }
        }
        ctx.putImageData(img, 0, 0);
    }

    async function updateGraph() {
        const res = await fetch('/history'); const data = await res.json();
        if(!data.length) return;
        const w = cvsGraph.width; const h = cvsGraph.height;
        ctxGraph.clearRect(0, 0, w, h);
        ctxGraph.strokeStyle = '#222'; ctxGraph.lineWidth = 1;
        ctxGraph.beginPath(); ctxGraph.moveTo(0, h/2); ctxGraph.lineTo(w, h/2); ctxGraph.stroke();
        const mapY = (val) => h - ((val / 10.0) * h);
        const stepX = w / Math.max(10, data.length);
        const drawLine = (key, color) => {
            ctxGraph.strokeStyle = color; ctxGraph.lineWidth = 2; ctxGraph.beginPath();
            data.forEach((pt, i) => {
                const x = i * stepX; const y = mapY(parseFloat(pt[key]));
                if(i===0) ctxGraph.moveTo(x, y); else ctxGraph.lineTo(x, y);
            });
            ctxGraph.stroke();
        };
        drawLine('Amygdala', '#f87171'); drawLine('Striatum', '#60a5fa'); drawLine('Hippocampus', '#34d399');
    }

    window.toggleLab = async function(start) {
        const endpoint = start ? '/lab/start' : '/lab/stop';
        const protocol = document.getElementById('lab-protocol-select').value;
        
        const body = start ? JSON.stringify({ test_id: protocol }) : "{}";

        // FIX: Capture the response to get the new wall layout
        const res = await fetch(endpoint, {
            method: 'POST', 
            headers: {'Content-Type': 'application/json'},
            body: body
        });
        const data = await res.json();
        
        document.getElementById('btn-start-lab').classList.toggle('hidden', start);
        document.getElementById('btn-stop-lab').classList.toggle('hidden', !start);
        
        if(start) {
            // FIX: If the backend sent new walls (e.g. empty box), rebuild the scene
            if(data.walls) buildWalls(data.walls);

            ctxLearning.clearRect(0,0, cvsLearning.width, cvsLearning.height);
            document.getElementById('lab-overlay').innerText = "ACQUIRING DATA...";
            isLabActive = true;
            pollLabResults();
        } else {
            isLabActive = false;
            resetRat(); // This puts the maze back
        }
    }

    async function pollLabResults() {
        if(!isLabActive) return;
        const res = await fetch('/lab/results');
        const data = await res.json();
        
        if(!data.active && data.data_points > 0) {
            isLabActive = false; 
            document.getElementById('btn-start-lab').classList.remove('hidden');
            document.getElementById('btn-stop-lab').classList.add('hidden');
            document.getElementById('lab-overlay').innerText = "EXPERIMENT COMPLETE";
            
            // FIX: Auto-refresh back to normal maze after 2 seconds
            setTimeout(() => {
                resetRat();
            }, 2000);
        }
        if(data.active) {
            document.getElementById('lab-overlay').innerText = `RUNNING: ${data.protocol || '...'}...`;
            setTimeout(pollLabResults, 1000);
        }
        drawLearningCurve(data.data);
    }

    function drawLearningCurve(dataPoints) {
        if(!dataPoints || dataPoints.length === 0) return;
        document.getElementById('lab-overlay').style.opacity = 0;
        
        const w = cvsLearning.width;
        const h = cvsLearning.height;
        ctxLearning.clearRect(0, 0, w, h);
        
        // Simple Plot: Distance from Center (Y) over Time (X)
        ctxLearning.strokeStyle = '#4ade80';
        ctxLearning.lineWidth = 1;
        ctxLearning.beginPath();
        
        const maxFrames = 1000; // Known max for Open Field
        
        dataPoints.forEach((pt, i) => {
            const x = (pt.frame / maxFrames) * w;
            // Map 0..20 distance to height. Center = top of graph.
            const y = h - ((pt.dist_from_center / 20.0) * h);
            
            if (i === 0) ctxLearning.moveTo(x, y);
            else ctxLearning.lineTo(x, y);
        });
        ctxLearning.stroke();
        
        // Add a "Center Zone" line
        ctxLearning.strokeStyle = '#333';
        ctxLearning.setLineDash([5, 5]);
        ctxLearning.beginPath();
        const centerLineY = h - ((12.0 / 20.0) * h); // 12.0 is radius of center zone
        ctxLearning.moveTo(0, centerLineY);
        ctxLearning.lineTo(w, centerLineY);
        ctxLearning.stroke();
        ctxLearning.setLineDash([]);
        
        // Update text
        const lastPt = dataPoints[dataPoints.length-1];
        document.getElementById('lab-status-text').innerHTML = 
            `Dist from Center: <span class=\"text-white\">${lastPt.dist_from_center.toFixed(1)}</span> | Entropy: <span class=\"text-purple-400\">${lastPt.entropy.toFixed(2)}</span>`;
    }

    // --- LOOP ---
    let lastRatPos = new THREE.Vector3();
    const pipCheck = document.getElementById('chk-pip');
    
    async function loop() {
        if(!running) { requestAnimationFrame(loop); return; }
        try {
            const payload = turboMode ? { batch_size: turboBatch } : {};
            const res = await fetch('/step', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(payload) });
            const data = await res.json();

            const newRatPos = new THREE.Vector3(data.rat[0], 0.5, data.rat[1]);
            ratMesh.position.copy(newRatPos);
            
            const moveDir = new THREE.Vector3().subVectors(newRatPos, lastRatPos);
            if (moveDir.lengthSq() > 0.001) {
                 const angle = Math.atan2(moveDir.z, moveDir.x);
                 ratMesh.rotation.set(Math.PI/2, 0, angle - Math.PI/2);
                 const bob = Math.sin(performance.now() / 100) * 0.05;
                 ratCamera.position.y = 0.2 + bob;
            }
            lastRatPos.copy(newRatPos);

            if(data.predator) {
                predatorMesh.position.set(data.predator[0], 0.5, data.predator[1]);
                predatorMesh.rotation.x += 0.05; predatorMesh.rotation.y += 0.05;
            }
            if(data.targets) {
                // Update active targets
                data.targets.forEach((target_pos, index) => {
                    if (targetMeshes[index]) {
                        targetMeshes[index].position.set(target_pos[0], 0.5, target_pos[1]);
                        targetLights[index].intensity = 1.0 + Math.sin(performance.now() / 200 + index * 0.5) * 0.5;
                        targetMeshes[index].visible = true; // Make sure it's visible
                    }
                });

                // FIX: Hide any extra target meshes that aren't in the current data
                // (e.g., if lab mode has 0 targets, hide all 3 meshes)
                for (let i = data.targets.length; i < targetMeshes.length; i++) {
                    targetMeshes[i].visible = false;
                }
            }

            // NEW: Check for dynamic wall updates from Lab Mode
            if (data.walls) {
                // Rebuild walls when payload includes updates
                buildWalls(data.walls);
            }

            pheromoneMeshes.forEach(m => m.visible = false);
            if(data.pheromones) {
                data.pheromones.slice(-500).forEach((pt, i) => {
                    const pm = pheromoneMeshes[i];
                    if(pm) { pm.visible = true; pm.position.set(pt[0], 0.1, pt[1]); }
                });
            }

            phantomMeshes.forEach(m => m.visible = false);
            if(data.phantom) {
                data.phantom.forEach((pt, i) => {
                    const ph = phantomMeshes[i];
                    if(ph) {
                        ph.visible = true; ph.position.set(pt[0], 0.5, pt[1]);
                        if(i > 0) {
                            const prev = data.phantom[i-1];
                            const angle = Math.atan2(pt[1]-prev[1], pt[0]-prev[0]);
                             ph.rotation.set(Math.PI/2, 0, angle - Math.PI/2);
                        }
                    }
                });
            }

            if (data.whiskers) {
                leftWhisker.rotation.y = 0.78 + data.whiskers.angle;
                rightWhisker.rotation.y = -0.78 - data.whiskers.angle;
                leftWhisker.material.color.setHex(data.whiskers.hits[0] ? 0xff0000 : 0xaaaaaa);
                leftWhisker.material.linewidth = data.whiskers.hits[0] ? 3 : 1;
                rightWhisker.material.color.setHex(data.whiskers.hits[1] ? 0xff0000 : 0xaaaaaa);
                rightWhisker.material.linewidth = data.whiskers.hits[1] ? 3 : 1;
            }

            if(data.vision && data.vision.length > 0) {
                const ratAngle = ratMesh.rotation.z + Math.PI/2;
                visionLines.forEach((line, i) => {
                    const ray = data.vision[i];
                    if(ray) {
                        line.visible = true;
                        line.rotation.y = ray.angle - ratAngle;
                        line.scale.z = ray.dist;
                        let color = 0x00ffff; 
                        if(ray.type === 0) color = 0x444444; 
                        if(ray.type === 2) color = 0xff0000; 
                        if(ray.type === 3) color = 0xffff00; 
                        line.material.color.setHex(color);
                        line.material.opacity = ray.type === 0 ? 0.1 : 0.5;
                    } else {
                        line.visible = false;
                    }
                });
            }
            
            const currentGen = data.stats.generation;
            if (currentGen > lastGen) {
                clearMemories(); 
                lastGen = currentGen;
                lastScore = 0;
            }
            const currentScore = data.stats.score;
            if (currentScore > lastScore) {
                spawnMemoryMarker(newRatPos);
                lastScore = currentScore;
            }
            memoryObjects.forEach(m => {
                m.rotation.y += 0.02;
                m.rotation.x += 0.01;
            });

            const stats = data.stats;
            document.getElementById('val-frust').innerText = stats.frustration.toFixed(2);
            document.getElementById('bar-frust').style.width = (stats.frustration*100) + '%';
            if(stats && stats.dopamine !== undefined) {
                document.getElementById('val-dopa').innerText = stats.dopamine.toFixed(2);
                document.getElementById('bar-dopa').style.width = (stats.dopamine*100) + '%';
                
                document.getElementById('val-energy').innerText = Math.round(stats.energy * 100) + '%';
                document.getElementById('bar-energy').style.width = (stats.energy * 100) + '%';
                
                const atpVal = stats.atp || 0; 
                const atpPercent = Math.min(100, Math.round(atpVal * 100)); 
                document.getElementById('val-atp').innerText = atpPercent + '%';
                document.getElementById('bar-atp').style.width = atpPercent + '%';
                
                // --- UPDATED VISUAL FEEDBACK ---
                const vignette = document.getElementById('energy-vignette');
                const threeCont = document.getElementById('three-container');

                if (atpVal < 0.3) {
                    // 1. Fade in the dark vignette (Tunnel Vision)
                    vignette.style.opacity = 1;
                    
                    // 2. Blur/Desaturate ONLY the 3D view, not the UI
                    threeCont.style.filter = "grayscale(70%) blur(1px)";
                    
                    // Optional: Pulse the ATP bar red
                    document.getElementById('bar-atp').classList.add('bg-red-500');
                    document.getElementById('bar-atp').classList.remove('bg-yellow-400');
                } else {
                    vignette.style.opacity = 0;
                    threeCont.style.filter = "none";
                    
                    document.getElementById('bar-atp').classList.remove('bg-red-500');
                    document.getElementById('bar-atp').classList.add('bg-yellow-400');
                    
                    // Clean up global filter if it was stuck from previous version
                    document.body.style.filter = "none";
                }

                document.getElementById('val-deaths').innerText = stats.deaths || 0;
                document.getElementById('val-gen').innerText = stats.generation || 1;
                document.getElementById('val-score').innerText = stats.score;
                document.getElementById('val-mems').innerText = memoryObjects.length;
            }

            const statusEl = document.getElementById('status-overlay');
            statusEl.innerText = stats.status;
            statusEl.className = stats.status === "DREAMING" ? "absolute top-4 left-4 text-xl font-bold animate-pulse text-cyan-300 pointer-events-none" : "absolute top-4 left-4 text-sm font-bold text-cyan-700 pointer-events-none";

            drawHeatmap(ctxBrain, data.brain.soma, v => { const b = Math.min(255, v * 500); return [b, b*0.2, b*0.1]; });
            if(data.brain.theta) drawHeatmap(ctxMem, data.brain.theta, v => { const b = Math.min(255, v * 50); return [b*0.8, 0, b]; });
            
            if (data.brain.hd) {
                const w = ctxHD.canvas.width;
                const h = ctxHD.canvas.height;
                const cx = w / 2;
                const cy = h / 2;
                const radius = w / 2 - 2;
                ctxHD.clearRect(0, 0, w, h);
                ctxHD.strokeStyle = '#222';
                ctxHD.lineWidth = 2;
                ctxHD.beginPath();
                ctxHD.arc(cx, cy, radius * 0.7, 0, Math.PI * 2);
                ctxHD.stroke();

                const cells = data.brain.hd;
                const step = (Math.PI * 2) / cells.length;
                ctxHD.beginPath();
                for (let i = 0; i < cells.length; i++) {
                    const activity = cells[i]; 
                    if (activity < 0.01) continue;
                    const angle = i * step - (Math.PI / 2); 
                    const mag = (radius * 0.5) + (activity * radius * 0.5);
                    const px = cx + Math.cos(angle) * mag;
                    const py = cy + Math.sin(angle) * mag;
                    const ix = cx + Math.cos(angle) * (radius * 0.5);
                    const iy = cy + Math.sin(angle) * (radius * 0.5);
                    ctxHD.moveTo(ix, iy);
                    ctxHD.lineTo(px, py);
                }
                ctxHD.strokeStyle = '#00ff00'; 
                ctxHD.lineWidth = 2;
                ctxHD.stroke();
            }

            if(data.brain.grid) drawHeatmap(ctxGrid, data.brain.grid, v => { 
                const g = Math.min(255, v * 255); 
                return [g*0.2, g, 0]; 
            });

            if(data.reset_visuals) updateGraph();

        } catch(e) { console.error(e); }

        const w = container.clientWidth;
        const h = container.clientHeight;

        renderer.setViewport(0, 0, w, h);
        renderer.setScissor(0, 0, w, h);
        renderer.setScissorTest(true);
        renderer.render(scene, mainCamera);

        if(pipCheck.checked) {
            const pipW = 320; 
            const pipH = 240;
            const pad = 10;
            renderer.setViewport(w - pipW - pad, pad, pipW, pipH);
            renderer.setScissor(w - pipW - pad, pad, pipW, pipH);
            renderer.setScissorTest(true);
            renderer.render(scene, ratCamera);
        }
        
        renderer.setScissorTest(false);
        requestAnimationFrame(loop);
    }

    window.resetRat = async function() {
        const res = await fetch('/reset', {method:'POST'});
        const data = await res.json();
        if(data.walls) buildWalls(data.walls);
        clearMemories(); 
        lastScore = 0;
        updateGraph();
    }
    window.loadGen = async function() {
      const id = document.getElementById('load-gen-input').value;
      if(!id) return;
      const res = await fetch('/load_generation', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ generation: id })
      });
      const data = await res.json();
      if (data.walls) buildWalls(data.walls);
      clearMemories();
      lastScore = 0;
      lastGen = parseInt(id, 10) || lastGen;
      updateGraph();
    };
    window.updateConfig = async function(key, val) { await fetch('/config', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({[key]: parseFloat(val)}) }); }
    document.getElementById('btn-play').onclick = function() { running = !running; this.innerText = running ? "Pause" : "Resume"; };
    document.getElementById('btn-turbo').onclick = () => setTurboMode(!turboMode);

    // --- TOOLTIP SYSTEM ---
    const tooltipEl = document.getElementById('global-tooltip');

    document.addEventListener('mouseover', (e) => {
        const target = e.target.closest('[data-tip]');
        if (target) {
            const key = target.getAttribute('data-tip');
            const data = TOOLTIP_TEXT[key];
            if (data) {
                tooltipEl.innerHTML = `<strong>${data.title}</strong>${data.text}`;
                tooltipEl.style.display = 'block';
            }
        }
    });

    document.addEventListener('mousemove', (e) => {
        if (tooltipEl.style.display === 'block') {
            let x = e.clientX + 15;
            let y = e.clientY + 15;
            if (x + 250 > window.innerWidth) x = e.clientX - 260;
            if (y + 100 > window.innerHeight) y = e.clientY - 100;
            tooltipEl.style.left = x + 'px';
            tooltipEl.style.top = y + 'px';
        }
    });

    document.addEventListener('mouseout', (e) => {
        const target = e.target.closest('[data-tip]');
        if (target) {
            tooltipEl.style.display = 'none';
        }
    });
    
    resetRat();
    resizeThree();
    loop();
</script>
</body>
</html>
